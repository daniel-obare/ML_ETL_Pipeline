# -*- coding: utf-8 -*-
"""Data Pipeline.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13lS3oarKiz7oiaMP7jiwfZOpNXNYrgeL

Objective is to build a pipeline from scratch - starting with retrieving weather data from the [OpenWeatherMap](https://openweathermap.org) current weather web API, parsing the data using Pandas (python data analysis) library 
and storing it in a local SQLite database.

**Get an API key and keep your API key private**

By making my API key an environment variable, it is hidden outside of my program and can be used without being exposed on my public GitHub repository. I saved my API key into a new file and called it .env .
"""

api-token = "danielobare"
# install dependencies
!pip install -r requirements.txt

# create a simple empy DB
import sqlite3


def create_DB_connection():
    """ Connect to a database and create cursor object for executing SQL statements.
    """
    connection = sqlite3.connect('CurrentWeatherDB.db', uri=True)
    print("Connection with database established ..........")
    connection.cursor()
    return connection


def close_connection(connection):
    """ Close connection with the database.
    """
    connection.commit()
    connection.close()

# Retrieve the data and save as a json file
from dotenv import load_dotenv
import os
import requests
import json


def get_current_weather_data_from_OpenWeatherMap(id):
    """ Returns current weather data by city id (Tel Aviv by default)
    """
    load_dotenv()
    json_data = requests.get(
        "http://api.openweathermap.org/data/2.5/weather?id="+id+"&appid="+os.environ.get("api-token")).json()
    print("Getting current weather data from OpenWeatherMap.org..........")
    return json_data


def write_weather_data_in_json_file(json_data):
    """ Save current weather data to a json file.
        Name the file by the Unix Timestamp.
    """
    name = 'data' + str(json_data['dt'])
    filename = r"data_cache/%s.json" % name
    with open(filename, 'w') as f:
        json.dump(json_data, f)
    return filename

#From json file to dictionary to Pandas Dataframe

"""
>>> convert_json_to_dict("data1600689959.json")
{'coord': {'lon': 34.78, 'lat': 32.08}, 'weather': [{'id': 800, 'main': 'Clear', 
'description': 'clear sky', 'icon': '01d'}], 'base': 'stations', 
'main': {'temp': 303.84, 'feels_like': 303.4, 'temp_min': 302.04, 
'temp_max': 305.37, 'pressure': 1010, 'humidity': 52}, 'visibility': 10000, 
'wind': {'speed': 5.7, 'deg': 310}, 'clouds': {'all': 0}, 'dt': 1600689959, 
'sys': {'type': 1, 'id': 6845, 'country': 'IL', 'sunrise': 1600658915, 
'sunset': 1600702755}, 'timezone': 10800, 'id': 293397, 'name': 'Tel Aviv', 'cod': 200}
>>> convert_dict_to_df("data1600689959.json")
0    10000
Name: visibility, dtype: int64
>>> convert_dict_to_df("data1601987692.json")
"""


import pandas as pd
import json
from pandas.io.json import json_normalize


def convert_json_to_dict(filename):
    """ Convert json file to python dictionary
    """
    with open(filename, 'r') as JSON:
        json_dict = json.load(JSON)
    return json_dict


def convert_dict_to_df(filename):
    """ Convert python dictionary to pandas dataframe
    """
    return pd.json_normalize(convert_json_to_dict(filename))


if __name__ == "__main__":
    import doctest
    doctest.testmod()

# ETL with Pandas
""" The ETL procedure enables us to extract and transform the data according to 
our analysis needs, and then load it to our data warehouse. In order to make my 
data useful for future Data Science projects, I made sure my database will 
contain necessary parameters for daily temperature prediction (current 
temperature in Celsius, minimal and maximal temperatures in Celsius, humidity, 
pressure and wind). Also, I chose the datetime ("dt") column to be the row index
 as a primary key for my database. """

 
"""
>>> convert_kelvin_to_celsius(df_test_convert_kelvin_to_celsius)
    temp  temp_min  temp_max  pressure  humidity  wind_speed  wind_deg          dt      name radiation
0  71.85     16.85     69.85        12        56         110       180  1600234345  Tel Aviv      high
1  15.85     24.85     59.85        13        67          90       189  1600456555  Tel Aviv       low
2  59.85     25.85     60.85        14        64          98       178  1600555666  Tel Aviv    medium
3  38.85    -55.15     71.85        15        63          99       177  1600567778  Tel Aviv   average
4  35.85     14.85    -41.15        11        62         100       190  1600776889  Tel Aviv       low
>>> keep_columns(df_test_keep_columns)
   main.temp  main.temp_min  main.temp_max  main.pressure  main.humidity  wind.speed  wind.deg          dt      name
0        345            290            343             12             56         110       180  1600234345  Tel Aviv
1        289            298            333             13             67          90       189  1600456555  Tel Aviv
2        333            299            334             14             64          98       178  1600555666  Tel Aviv
3        312            218            345             15             63          99       177  1600567778  Tel Aviv
4        309            288            232             11             62         100       190  1600776889  Tel Aviv
"""

import pandas as pd

# Fake data for testing
data_test_keep_columns = {'main.temp': [345, 289, 333, 312, 309],
                         'main.temp_min': [290, 298, 299, 218, 288],
                         'main.temp_max': [343, 333, 334, 345, 232],
                         'main.pressure': [12,13,14,15,11],
                         'main.humidity': [56,67,64,63,62],
                         'wind.speed': [110,90,98,99,100],
                         'wind.deg': [180,189,178,177,190],
                         'dt': [1600234345,1600456555,1600555666,1600567778,1600776889],
                         'name': 'Tel Aviv',
                         'radiation':['high','low','medium','average','low']}

df_test_keep_columns = pd.DataFrame(data_test_keep_columns)
data_test_convert_kelvin_to_celsius = {'temp': [345, 289, 333, 312, 309],
                         'temp_min': [290, 298, 299, 218, 288],
                         'temp_max': [343, 333, 334, 345, 232],
                         'pressure': [12,13,14,15,11],
                         'humidity': [56,67,64,63,62],
                         'wind_speed': [110,90,98,99,100],
                         'wind_deg': [180,189,178,177,190],
                         'dt': [1600234345,1600456555,1600555666,1600567778,1600776889],
                         'name': 'Tel Aviv',
                         'radiation':['high','low','medium','average','low']}

df_test_convert_kelvin_to_celsius = pd.DataFrame(data_test_convert_kelvin_to_celsius)

def keep_columns(pandas_df):
    """ Keep only the necessary columns of the dataframe
    """
    return pandas_df[['main.temp','main.temp_min','main.temp_max','main.pressure','main.humidity','wind.speed','wind.deg','dt','name']]


def change_col_name(pandas_df_kept_columns):
    """ Change columns names to  match the SQL database.
    """
    return pandas_df_kept_columns.rename(columns={'main.temp': 'temp', 'main.temp_min': 'temp_min', 'main.temp_max': 'temp_max', 'main.pressure': 'pressure', 'main.humidity': 'humidity', 'wind.speed': 'wind_speed', 'wind.deg': 'wind_deg'})


def convert_kelvin_to_celsius(pandas_df_kept_renamed_columns):
    """ Convert the temp, temp_min, temp_max measurement unit from Kelvin to Celsius.
    """
    columns = ["temp", "temp_min", "temp_max"]
    for column in columns:
        pandas_df_kept_renamed_columns[column] = pandas_df_kept_renamed_columns[column] - 273.15
    return pandas_df_kept_renamed_columns


def set_datetime_col_as_row_index(pandas_df_kept_renamed_columns_in_celsius):
    """ Set the datetime column to be the dataframe row index.
    """
    return pandas_df_kept_renamed_columns_in_celsius.set_index('dt')


if __name__ == "__main__":
    import doctest
    doctest.testmod()

# Update the Database

import sqlite3
import pandas as pd


def update_db(pandas_df, connection):
    """ Upload pandas dataframe to sql database
    """
    pandas_df.to_sql('Weather', connection, if_exists='append', index=True)
    print("Uploaded to database!")


if __name__ == "__main__":
    import doctest
    doctest.testmod()

"""For flexibility, I used the argparse library, which lets you run main.py from the command line and give it a city id as an optional argument. So even though I defined Tel Aviv city by default, the user can still run the program for any city in the world. For example, if you would like to get the weather data of Detroit, US:"""

python3 src/main.py --city_id "4990729"

# main.py
from create_db import create_DB_connection, close_connection
from create_pandas_df_from_json import convert_dict_to_df
from update_db import update_db
from transform import keep_columns, change_col_name, convert_kelvin_to_celsius, set_datetime_col_as_row_index
from get_weather_data_from_OpenWeatherMap import get_current_weather_data_from_OpenWeatherMap, write_weather_data_in_json_file
import argparse
import time

parser = argparse.ArgumentParser()
parser.add_argument("--city_id", default="293397", help="Fetch weather data for a specified city. Find the id of the city on OpenWeatherMap.org")
parser.add_argument("--frequency", default=900, type=int, help="How often does the program run in seconds")
args = parser.parse_args()
if args.city_id:
    print("city id inserted")
if args.city_id:
    print("program frequency inserted")


def start():
    returned_connection = create_DB_connection()
    filename = write_weather_data_in_json_file(
        get_current_weather_data_from_OpenWeatherMap(args.city_id))
    new_df_to_sql = set_datetime_col_as_row_index(convert_kelvin_to_celsius(
        change_col_name(keep_columns(convert_dict_to_df(filename)))))

    update_db(new_df_to_sql, returned_connection)

    close_connection(returned_connection)


while True:
    start()
    time.sleep(args.frequency)

""" The program runs on a default schedule every 15 minutes by using a while loop, and you can set the frequency 
to any you would like. For example, in order to run it every 5 seconds, run the command: """

python3 src/main.py --frequency 5